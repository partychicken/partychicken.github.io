{"meta":{"title":"PC 的 blog","subtitle":"","description":"","author":"partychicken","url":"http://partychicken.github.io","root":"/"},"pages":[{"title":"links","date":"2020-04-22T12:46:25.000Z","updated":"2022-04-22T11:58:59.180Z","comments":true,"path":"PY.html","permalink":"http://partychicken.github.io/PY.html","excerpt":"","text":""}],"posts":[{"title":"抽象数据类型 (ADT)","slug":"6 抽象数据类型 (ADT)","date":"2022-06-14T09:34:00.000Z","updated":"2022-06-14T11:36:14.328Z","comments":true,"path":"2022/06/14/6 抽象数据类型 (ADT)/","link":"","permalink":"http://partychicken.github.io/2022/06/14/6%20%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20(ADT)/","excerpt":"","text":"6 抽象数据类型 (ADT)抽象数据类型与表示独立性：如何设计良好的抽象数据结构，通过封装来避免客户端获取数据的内部表示（即“表示泄露”），避免潜在 的bug——在client和implementer之间建立“防火墙” ADT的特性：表示泄漏、抽象函数AF、表示不变量RI 基于数学的形式对ADT的这些核心特征进行描述并应用于设计中。 Abstraction and User-Defined Types除了编程语言所提供的基本数据类型和对象数据类型，程序员可定义自己的数据类型 数据抽象：由一组操作所刻画的数据类型 传统的类型定义：关注数据的具体表示 抽象类型：强调“作用于数据上的操作”，程序员和 client无需关心数据如何具体存储的，只需设计/使用操作即可 ADT是由操作定义的，与其内部如何实现无关！ Classifying Types and OperationsMutable and immutable types可变类型的对象：提供了可改变其内部数据的值的操作 不变数据类型： 其操作不改变内部值，而是构造新的对象 Operations 构造器 生产器 观察器 变值器 Abstract Data Type Examplesint and String都是不可变的，没有变值器。 List Designing an Abstract Type设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约 spec Rules: 设计简洁、一致的操作 要足以支持client对数据所做的所有操作需要，且用操作满足client需要的难度要低 Representation Independence表示独立性：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。 Testing an Abstract Data Type测试creators, producers, and mutators：调用 observers 来观察这些 operations 的结果是否满足spec； 测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。 风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。 Invariants不变量：在任何时候总是true immutability就是一个典型的“不变量” 由ADT来负责其不变量，与client端的任何行为无关 可以使用 private 和 final 关键字来进行限制 Rep Invariant and Abstraction Function R: the space of representation values (rep values) consists of the values of the actual implementation entities. A: the space of abstract values consists of the values that the type is designed to support. client看到和使用的值 Every abstract value is mapped to by some rep value (surjective, 满射). Some abstract values are mapped to by more than one rep value (not injective, 未必单射). Not all rep values are mapped (not bijective, 未必双射) Abstraction Function抽象函数：R和A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。 Rep Invariant表示不变性RI：某个具体的“表示”是否是“合法的” 也可将RI看作：所有表示值的一个子集，包含了所有合法的表示值 也可将RI看作：一个条件，描述了什么是“合法”的表示值 Both the rep invariant and the abstraction function should be documented in the code, right next to the declaration of the rep itself: The abstract value space alone doesn’t determine AF or RI 设计ADT： 选择R和A； RI —- 合法的表示值； 如何解释合法的表示值 —-映射AF 做出具体的解释：每个rep value如何映射到abstract value 在所有可能改变rep的方法内都要检查 Observer方法可以不用，但建议也要检查，以防止你的“万一” Calling checkRep() in every method, including observers, means you’ll be more likely to catch rep invariant violations caused by rep exposure. Beneficent mutation对immutable的ADT来说，它在A空间的abstract value应是不变的。但其内部表示的R空间中的取值则可以是变化的。这种变化称为有益的可变性（Beneficent mutation） Documenting the AF, RI, and Safety from Rep Exposure在代码中用注释形式记录AF和RI 要精确的记录RI：rep中的所有fields何为有效 要精确记录AF：如何解释每一个R值 Another piece of documentation is a rep exposure safety argument 表示泄漏的安全声明 给出理由，证明代码并未对外泄露其内部表示——自证清白 ADT的规约里只能使用client可见的内容来撰写，包括参数、返回值、异常等。如果规约里需要提及“值”，只能使用A空间中的“值”。ADT的规约里也不应谈及任何内部表示的细节，以及R空间中的任何值，ADT的内部表示(私有属性)对外部都应严格不可见。故在代码中以注释的形式写出AF和RI而不能在Javadoc文档中，防止被外部看到而破坏表示独立性/信息隐藏。 在对象的初始状态不变量为true，在对象发生变化时，不变量也要为true。即： 构造器和生产器在创建对象时要确保不变量为true 变值器和观察器在执行时必须保持不变性。 在每个方法return之前，用checkRep()检查不变量是否得以保持。 ADT invariants replace preconditions用ADT不变量取代复杂的Precondition，相当于将复杂的precondition封装到了ADT内部。","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"ADT和OOP中的“等价性”","slug":"8 ADT和OOP中的“等价性”","date":"2022-06-14T09:34:00.000Z","updated":"2022-06-14T11:36:37.080Z","comments":true,"path":"2022/06/14/8 ADT和OOP中的“等价性”/","link":"","permalink":"http://partychicken.github.io/2022/06/14/8%20ADT%E5%92%8COOP%E4%B8%AD%E7%9A%84%E2%80%9C%E7%AD%89%E4%BB%B7%E6%80%A7%E2%80%9D/","excerpt":"","text":"8 ADT和OOP中的“等价性”Equivalence Relation等价关系：自反、对称、传递 For a boolean-valued binary operation like == or equals(), the equivalence E is the set of pairs (x,y) for which the operation returns true. Equality of Immutable TypesUsing AF to define the quality, AF映射到同样的结果，则等价 An equivalence relation induces an abstraction function (the relation partitions T, so f maps each element to its partition class). The relation induced by an abstraction function is an equivalence relation. 站在外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。反之亦然！ == vs. equals()The == operator compares references. It tests referential equality. The equals() operation compares object contents – in other words, object equality. 在自定义ADT时，需要重写Object的equals()。 == 对基本数据类型，使用==判定相等 对对象类型，使用equals() Implementing equals()在Object中实现的缺省equals()是在判断引用等价性，这通常不是程序员所期望的。因此，需要重写。 注意区分Overload和override，重写时要使用 @Override ，编译器会检查超类中是否含有相同签名的函数。 In general, using instanceof in object-oriented programming is a bad smell. It should be disallowed anywhere except for implementing equals . The Object contract除非对象被修改了，否则调用多次equals应同样的结果 “相等”的对象，其 hashCode() 的结果必须 一致 Object ’s default hashCode() implementation is consistent with its default equals() The standard is to compute a hash code for each component of the object that is used in the determination of equality (usually by calling the hashCode method of each component), and then combining these, throwing in a few arithmetic operations. Always override hashCode() when you override equals() Equality of Mutable Types观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致 行为等价性：调用对象的任何方法都展示出一致的结果 对可变类型，实现行为等价性即可 也就是说，只有指向同样内存空间的objects，才是相等的。 所以对可变类型来说，无需重写这两个函数，直接继承Object的两个方法即可。 如果一定要判断两个可变对象看起来是否一致，最好定义一个新的方法。 Autoboxing and Equality","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"面向对象的编程","slug":"7 面向对象的编程","date":"2022-06-14T09:34:00.000Z","updated":"2022-06-14T11:36:27.180Z","comments":true,"path":"2022/06/14/7 面向对象的编程/","link":"","permalink":"http://partychicken.github.io/2022/06/14/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/","excerpt":"","text":"7 面向对象的编程Basic concepts: object, class, attribute, and methodClass variable 类成员变量: a variable associated with the class rather than with an instance of the class. You can also associate methods with a class—class methods类方法 Methods and variables that are not class methods or class variables are known as instance methods 实例方法 and instance variables 实例成员变量. Interface Interface和Class: 定义和实现ADT 接口之间可以继承与扩展 一个类可以实现多个接口（从而具备了多个接口中的方法） 一个接口可以有多种实现类 接口：确定ADT规约；类：实现ADT 也可以不需要接口直接使用类作为ADT，既有ADT定义也有ADT实现 实际中更倾向于使用接口来定义变量 Using static factory instead of constructor 接口中的每个方法在所有类中都要实现，可以通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。 Inheritance and OverridingOverridingRewriteable Method: A method which allow a re-implementation. Strict inheritance 严格继承：子类只能添加新方法，无法重写超类中的方法 (用final修饰) Strict inheritance OverridingMethod overriding is a language feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its superclasses or parent classes. 重写的函数：完全同样的signature 实际执行时调用哪个方法，运行时决定。 如果父类型中的某个函数实现体为空 意味着其所有子类型都需要这个功能，但各有差异，没有共性，在每个子类中均需要重写。 When a subclass contains a method that overrides a method of the superclass, it can also invoke the superclass method by using the keyword super. Bad Use of Overwriting Methods: 重写的时候，不要改变原方法的本意 Abstract ClassAbstract method: A method with a signature but without an implementation (also called abstract operation) Defined by the keyword abstract Abstract class: A class which contains at least one abstract method is called abstract class Interface: An abstract class which has only abstract methods An interface is primarily used for the specification of a system or subsystem. The implementation is provided by a subclass or by other mechanisms. 如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写 所有子类型完全相同的操作，放在父类型中实现，子类型中无需重写。 有些子类型有而其他子类型无的操作，不要在父类型中定义和实现，而应在特定子类型中实现。 Polymorphism, subtyping and overloadingThree Types of PolymorphismAd hoc polymorphism (特殊多态)：when a function denotes different and potentially heterogeneous implementations depending on a limited range of individually specified types and combinations. Parametric polymorphism (参数化多态): when code is written without mention of any specific type and thus can be used transparently with any number of new types.(often known as generics or generic programming 泛型) Subtyping (also called subtype polymorphism or inclusion polymorphism 子类型多态、包含多态): when a name denotes instances of many different classes related by some common superclass. Ad hoc polymorphism and OverloadingAd-hoc polymorphism is obtained when a function works on several different types (which may not exhibit a common structure) and may behave in unrelated ways for each type. 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型 价值：方便client调用，client可用不同的参数列表，调用同样的函数 Overloading is a static polymorphism 根据参数列表进行最佳匹配 静态类型检查 在编译阶段时决定要具体执行哪个方法 与之相反，overridden methods则是在run-time进行dynamic checking！ Overloading rules: MUST change the argument list. 不同的参数列表 CAN change the return type. 相同/不同的返回值类型 CAN change the access modifier. 相同/不同的 public/private/protected CAN declare new or broader checked exceptions. 异常 A method can be overloaded in the same class or in a subclass. 可以在同一个类内重载，也可在子类中重载 Overriding vs. Overloading Parametric polymorphism and Generic programmingParametric polymorphism is obtained when a function works uniformly on a range of types; these types normally exhibit some common structure. Generic programming is a style of programming in which data types and functions are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. Suppose we want to implement the generic Set interface. 泛型接口，非泛型的实现类 泛型接口，泛型的实现类 Subtyping Polymorphism Benefits of inheritance/subtype: Reuse of code, Modeling flexibility In Java: Each class can directly extend only one parent class; A class can implement multiple interfaces. “B is a subtype of A” means “every B is an A.” In terms of specifications: “every B satisfies the specification for A.” If you declare a subtype in Java (e.g., implementing an interface), then you must ensure that the subtype’s spec is at least as strong as the supertype’s.子类型的规约不能弱化超类型的规约。 子类型多态：不同类型的对象可以统一的处理而无需区分 Each object behaves according to its type (e.g., if you add new kind of account, client code does not change) 从而隔离了“变化” instanceofOperator that tests whether an object is of a given class Advice: avoid instanceof() if possible, and never(?) use instanceof() in a superclass to check type against subclass. Some important Object methods in JavaOverriding Object method equals() – true if the two objects are “equal” hashCode() – a hash code for use in hash maps toString() – a printable string representation toString() – ugly and uninformative You know what your object is so you can do better Always override unless you know in won’t be called equals &amp; hashCode – identity semantics You must override if you want value semantics Otherwise don’t Designing good classesAdvantages of immutable classes Simplicity Inherently Thread-Safe Can be shared freely No need for defensive copies Excellent building blocks How to write an immutable class Don’t provide any mutators Ensure that no methods may be overridden Make all fields final Make all fields private Ensure security of any mutable components (avoid rep exposure) Implement toString(), hashCode(), clone(), equals(), etc. Q: When to make classes immutable? A: Always, unless there’s a good reason not to Always make small “value classes” immutable!","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"设计规约","slug":"5 设计规约","date":"2022-06-11T09:34:00.000Z","updated":"2022-06-14T11:36:04.367Z","comments":true,"path":"2022/06/11/5 设计规约/","link":"","permalink":"http://partychicken.github.io/2022/06/11/5%20%E8%AE%BE%E8%AE%A1%E8%A7%84%E7%BA%A6/","excerpt":"","text":"5 设计规约Functions &amp; methods in programming languages12345[…] NAME (TYPE NAME, TYPE NAME) &#123; STATEMENTS &#125; To call: NAME(arg1, arg2); 参数类型是否匹配，在静态类型检查阶段完成 12345public static TYPE NAME() &#123; STATEMENTS; return EXPRESSION; &#125;//void means “no type” 返回值类型是否匹配，也在静态类型检查阶段完成 “方法”是程序的“积木”，可以被独立开发、测试、复用 使用“方法”的客户端，无需了解方法内部具体如何工作—“抽象” Specification: Programming for communicationDocumenting in programming 变量的数据类型定义 final关键字定义了设计决策：“不可改变” 代码中蕴含的“设计决策”：给编译器读 注释形式的“设计决策”：给自己和别人读 Specification and Contract (of a method)规约是合作的关键。没规约，没法写程序；即使写出来，也不知道对错。 规约是程序与客户端之间达成的一致，Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守。 规约可以隔离“变化”，无需通知客户端。 规约也可以提高代码效率。 规约：扮演“防火墙”角色。 规约内容包含： 输入/输出的数据类型 功能和正确性 性能 只讲“能做什么”，不讲 “怎么实现” Behavioral equivalenceTo determine behavioral equivalence , the question is whether we could substitute one implementation for the other.(站在客户端视角看行为等价性) 根据规约判断是否行为等价。 Specification structure: pre-condition and post-condition前置条件：对客户端的约束，在使用方法时必须满足的条件 后置条件：对开发者的约束，方法结束时必须满足的条件 契约：如果前置条件满足了，后置条件必须满足 Parameters are described by @param clauses and results are described by @return and @throws clauses. Put the preconditions into @param where possible, and postconditions into @return and @throws. 除非在后置条件里声明过，否则方法内部不应该改变输入参数 应尽量遵循此规则，尽量不设计 mutating 的 spec，否则就容易引发 bugs。 Designing specificationsClassifying specifications对规约进行比较： 规约的确定性 规约的陈述性 规约的强度 用于判断“哪个规约更好” 规约的强度S2&gt;=S1,需满足： 前置条件更弱 后置条件更强 就可以用S2替代S1 越强的规约，意味着 implementer 的自由度和责任越重，而client的责任越轻。 Diagramming specification使用点表示实现方法，则每个规约就是包含满足其条件的所有实现的区域。 程序员可以在规约的范围内自由选择实现方式，客户端无需了解具体使用了哪个实现。 更强的规约，表达为更小的区域。 Designing good specifications一个好的“方法”设计，并不是你的代码写的多么好，而是你对该方法的spec设计得如何。 (1) The specification should be coherentcoherent——内聚的 Spec描述的功能应单一、简单、易理解。 (2) The specification should be strong enough太弱的spec，client不放心、不敢用 (因为没有给出足够的承诺)。 开发者应尽可能考虑各种特殊情况，在post-condition给出处理措施。 (3) The specification should also be weak enough太强的spec，在很多特殊情况下难以达到，给开发者增加了实现的难度。 (4) The specification should use abstract types在规约里使用抽象类型，可以给方法的实现体与客户端更大的自由度。 In Java, this often means using an interface type, like Map or Reader, instead of specific implementation types like HashMap or FileReader. (5) Precondition?是否应该使用前置条件？在方法正式执行之前，是否要检查前置条件已被满足？ 不写Precondition，就要在代码内部check；若代价太大，在规约里加入precondition，把责任交给client 是否使用前置条件取决于 check的代价； 方法的使用范围 如果只在类的内部使用该方法(private)，那么可以不使用前置条件，在使用该方法的各个位置进行check——责任交给内部client； 如果在其他地方使用该方法(public)，那么必须要使用前置条件，若client端不满足则方法抛出异常。","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"数据类型与类型检验","slug":"4 数据类型与类型检验","date":"2022-06-03T09:34:00.000Z","updated":"2022-06-14T11:35:56.705Z","comments":true,"path":"2022/06/03/4 数据类型与类型检验/","link":"","permalink":"http://partychicken.github.io/2022/06/03/4%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E9%AA%8C/","excerpt":"","text":"4 数据类型与类型检验Data type in programming languagesType and VariablesA type is a set of values, along with operations that can be performed on those values. Variables: Named location that stores a value of one particular type. Types in JavaPrimitive types 基本数据类型: int, long, boolean Object types 对象数据类型: String represents a sequence of characters. BigInteger represents an integer of arbitrary size 对象类型形成层次结构 If extends clause omitted, defaults to Object. A class is an instance of all its superclasses. Inherits visible fields and methods from its superclasses Can override methods to change their behavior Static vs. dynamic data type checking类型转换 Static Typing vs. Dynamic TypingJava is a statically-typed language. 静态类型语言 每个变量的类型在编译时确定 同类型变量运算结果默认为该类型 在编译阶段进行类型检查 In dynamically-typed languages like Python, this kind of checking is deferred until runtime (while the program is running). 动态类型语言 在运行阶段进行类型检查 静态类型检查：可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性 静态检查：关于“类型”的检查，不考虑值 动态检查：关于“值”的检查 Mutability and Immutability赋值Use “=” to give variables a value Changing a variable or its value改变一个变量：将该变量指向另一个值的存储空间 改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 尽可能避免变化，以避免副作用。 不变性：重要设计原则不变数据类型：一旦被创建，其值不能改变 如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变 使用关键字 final 修饰 如果编译器无法确定final变量不会改变，就提示错误，这也是静态类型检查的一部分。 尽量使用 final 变量作为方法的输入参数、作为局部变量。 final类无法派生子类 变量无法改变值/引用 final方法无法被子类重写 String as an immutable type String is an example of an immutable type. A String object always represents the same string. Since String is immutable, once created, a String object always has the same value. To add something to the end of a String, you have to create a new String object: StringBuilder as a mutable type StringBuilder is an example of a mutable type. It has methods to delete parts of the string, insert or replace characters, etc. This class has methods that change the value of the object, rather than just returning new values Advantages of mutable types使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，可变类型最少化拷贝以提高效率。 使用可变数据类型，可获得更好的性能，也适合于在多个模块之间共享数据。 可以通过防御式拷贝，给客户端返回一个新的Date对象，防止对mutable变量的修改。如果使用不可变类型，则节省了频繁复制的代价。 安全的使用可变类型：局部变量，不会涉及共享；只有一个引用。 如果有多个引用（别名），使用可变类型就非常不安全。 Snapshot diagram as a code-level, run-time, and moment viewSnapshot diagrams 用于描述程序运行时的内部状态，便于程序员之间的交流，便于刻画各类变量随时间变化，便于解释设计思路。 基本类型的值: 对象类型的值： 不可变对象：用双线椭圆 不可变的引用：用双线箭头 Complex data types: Arrays and CollectionsArrayArrays are fixed-length sequences of another type T. The int[] array type includes all possible array values, but a particular array value, once created, can never change its length. ListLists are variable-length sequences of another type T . List is an interface. Members in a List must be an object. SetA Set is an unordered collection of zero or more unique objects. Set is an abstract interface MapA Map is similar to a dictionary (key-value) Map is an abstract interface Iterator Useful immutable types基本类型及其封装对象类型都是不可变的。 Don’t use mutable Date, use the appropriate immutable type from java.time based on the granularity of timekeeping you need. The Collections utility class has methods for obtaining unmodifiable views of these mutable collections: Collections.unmodifiableList Collections.unmodifiableSet Collections.unmodifiableMap 这种包装器得到的结果是不可变的：只能看。但是这种“不可变”是在运行阶段获得的，编译阶段无法据此进行静态检查","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"软件构造过程与配置管理","slug":"3 软件构造过程与配置管理","date":"2022-05-24T09:34:00.000Z","updated":"2022-06-14T11:35:45.632Z","comments":true,"path":"2022/05/24/3 软件构造过程与配置管理/","link":"","permalink":"http://partychicken.github.io/2022/05/24/3%20%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/","excerpt":"","text":"3 软件构造过程与配置管理Software Development LifecycleFrom 0 to 1 From 1 to n Traditional Software Process ModelsTwo basic types： Linear 线性过程 Iterative 迭代过程 Existing models： 瀑布过程 增量过程 V字模型 原型过程 螺旋模型 选择合适的过程模型的依据 用户参与程度有多大？—适应变化的能力 开发效率/管理复杂度 开发出的软件的质量 Waterfall 瀑布过程 线性推进 阶段划分清楚 整体推进 无迭代 管理简单 无法适应需求增加/变化 Incremental 增量过程 线性推进 增量式（多个瀑布的串行） 无迭代 比较容易适应需求的增加 V-Model (for verification and validation) V字模型 Prototyping 原型过程 迭代：开发出来之后由用户试用/评审，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。 循环往复这个过程，直到用户满意为止。 时间代价高，但开发质量也高。 Spiral 螺旋模型 多轮迭代基本遵循瀑布模式 每轮迭代有明确的目标，遵循“原型”过程，进行严格的风险分析，方可进入下一轮迭代 Agile Development敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。 敏捷宣言： Agile = 增量 + 迭代 每次迭代处理一个小规模增量 Software Configuration Management (SCM) and Version Control System (VCS)SCM软件配置管理：追踪和控制软件的变化 SCM practices include revision control and the establishment of baselines. 仓库：即于SCM中的CMDB 工作拷贝：在开发者本地机器上的一份项目拷贝 文件：一个独立的配置项 版本：在某个特定时间点的所有文件的共同状态 变化：即code churn，两个版本之间的差异 HEAD：程序员正在其上工作的版本 VCS - Version Control System本地版本控制系统： 仓库存储于开发者本地机器，无法共享和协作 集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作 分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 Git as an example of SCM tool A Git repository has three parts: .git directory (a repository storing all version control data) 本地的CMDB Working directory (local file system) 工作目录：本地文件系统 Staging area (in memory) 暂存区：隔离工作目录和Git仓库 文件的三种状态：已修改，、已暂存，已提交 Object GraphThe Git object graph is stored in the .git directory of the repository. Object Graph记录了项目的历史，是DAG。 每个commit指向一个父亲 多个commit指向同一个父亲：分支 一个 commit 指向两个父亲：合并 A branch is just a name that points to a commit. HEAD points to the current commit. CommitGit object graph stores each version of an individual file once, and allows multiple commits to share that one copy. Each commit also has log data — who, when, short log message, etc. 传统VCS存储版本之间的变化（行） Git存储发生变化的文件（而非代码行）,不变化的文件不重复存储 Branch/MergeA branch is the duplication of an object under revision control so that modifications can happen in parallel along both branches. Merging two branches together. Collaboration GitHub Basic process: commit, branch and merge Collaboration process: fork and pull request General process of software construction ProgrammingConstruction languages从用途上划分: Programming languages (e.g. C, C++, Java, Python) 编程语言 Modeling languages (e.g. UML) 建模语言 Configuration languages (e.g. XML) 配置语言 Build languages (e.g. XML) 构建语言 从形态上划分 Linguistic-based 基于语言学的构造语言 Mathematics-based (formal) 基于数学的形式化构造语言 Graphics-based (visual) 基于图形的可视化构造语言 Programming toolsIDE: 集成开发环境，包括： 源代码编辑器、智能代码补全工具、代码重构工具 文件管理 库管理 软件逻辑实体可视化 图形化用户界面构造器 (GUI builder) 编译器、解释器 自动化build工具 版本控制系统 外部的第三方工具 Review and static code analysis包含：结对编程 走查 正式评审会议 自动化评审 利用工具进行的静态代码分析: CheckStyle, SpotBugs, PMD for Java Dynamic code analysis / profiling动态分析：要执行程序并观察现象、收集数据、分析不足 Profiling：对代码的运行时状态和性能进行度量，发现代码中的潜在问题。 Debugging and Testing测试：发现程序是否有错误 调试：定位错误、发现错误根源 Refactoring重构：在不改变功能的前提下优化代码 Narrow-sense process of software construction (Build）粗略理解build： build-time $\\to$ run-time 借助于工具，将软件构造各阶段的活动“自动化” (编译、打包、静态分析、测试、生成文档、部署、…) 尽可能脱离“手工作业”，提高构造效率","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"HIT ICS 大作业","slug":"ics","date":"2022-05-19T14:14:00.000Z","updated":"2022-05-19T14:29:16.654Z","comments":true,"path":"2022/05/19/ics/","link":"","permalink":"http://partychicken.github.io/2022/05/19/ics/","excerpt":"","text":"","categories":[{"name":"ICS","slug":"ICS","permalink":"http://partychicken.github.io/categories/ICS/"}],"tags":[]},{"title":"软件测试与测试优先的编程","slug":"2 软件测试与测试优先的编程","date":"2022-05-16T09:34:00.000Z","updated":"2022-06-14T11:35:26.700Z","comments":true,"path":"2022/05/16/2 软件测试与测试优先的编程/","link":"","permalink":"http://partychicken.github.io/2022/05/16/2%20%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95%E4%BC%98%E5%85%88%E7%9A%84%E7%BC%96%E7%A8%8B/","excerpt":"","text":"2 软件测试与测试优先的编程Software TestingWhat is testing测试是提高软件质量的重要手段。测试是为了找到 bug 而对程序进行执行的过程，在过程中确认软件是否达到可用级别（用户需求）。 一个测试通常只关注系统的某一侧面的质量特性。 即使是最好的测试，也无法达到100%的保证无错误。 Residual defect rates (残留缺陷率) 1-10 defects/kloc : Typical industry software 0.1-1 defects/kloc: High-quality validation. (Java libraries might achieve) 0.01-0.1 defects/kloc: The very best, safety-critical validation. (NASA and companies like Praxis can achieve this level.) 对于大型系统来说，这个缺陷率显得很震撼。（如果是 1 百万行的代码，那么整个系统就有1000个bug） Test characteristics目标：破坏、证错、“负能量” 再好的测试也无法证明系统里不存在错误 好的测试应具有如下特性： 能发现错误 不冗余 最佳特性 别太复杂也别太简单 Test levelsUnit testing：单元测试 Integration testing：集成测试 System testing：系统测试 Acceptance testing：验收测试 Regression testing：回归测试 Other testing types 一些对立分类Static vs. DynamicStatic testing is performed without actually executing programs. Reviews, walkthroughs, or inspections are referred to as static testing. Dynamic testing describes the testing of the dynamic behavior of code, which actually executes programmed code with a given set of test cases. Testing vs. Debugging测试：发现是否存在错误 调试：识别错误根源，消除错误 White-box vs. black-box白盒测试：对程序内部代码结构的测试 黑盒测试：对程序外部表现出来的行为的测试 Why Software Testing is Hard Exhaustive testing is infeasible 偶然的测试没有意义 基于样本的统计数据对软件测试意义不大 软件行为在离散输入空间中差异巨大 无统计分布规律可循 Test CaseWhat is test case？ test case = \\{test inputs + execution conditions + expected results\\}Characteristics of good test case Most likely to catch the wrong 最可能发现错误 Not repetitive and not redundant 不重复、不冗余 The most effective in a group of similar test cases 最有效 Neither too simple nor too complicated 既不简单也不复杂 Test-First ProgrammingProcess: Write a specification for the function. 先写spec Write tests that exercise the specification. 再写符合spec的测试用例 Write the actual code. Once your code passes the tests you wrote, you’re done. 写代码、执行测试、有问题再改、再执行测试用例，直到通过它 Unit TestingUnit testing focuses verification effort on the smallest unit of software design—the software component or module. 针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试 JUnit略 Black-box Testing黑盒测试：用于检查代码的功能，不关心内部实现细节 Black-box testing attempts to find errors in the following types: Incorrect or missing functions Interface errors Errors in data structures or external database access Behavior or performance errors Initialization and termination errors 用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。 Choosing Test Cases by Partitioning基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。 针对每个输入数据需要满足的约束条件，划分等价类。 每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合。 基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可 Include Boundaries in the Partition大量的错误发生在输入域的“边界”而非中央。 边界值分析方法是对等价类划分方法的补充。 Two Extremes for Covering the Partition Full Cartesian product 笛卡尔积：全覆盖 测试完备，但用例数量多，测试代价高 Cover each part 覆盖每个取值：最少1次即可 测试用例少，代价低，但测试覆盖度未必高。 White-box Testing白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例。 白盒测试一般较早执行。 独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖1次。 Coverage of TestingCode coverage代码覆盖度：已有的测试用例有多大程度覆盖了被测程序 There are many common kinds of coverage: Function coverage: has each function in program been called? 函数覆盖 Statement coverage: is every statement run by some test case? 语句覆盖 Branch coverage: for every if or while or switch-case or for statement in the program, are both the true and the false direction taken by some test case? 分支覆盖 Condition coverage: for every condition in if/while/for/switch-case statement, are both the true/false direction taken by some test case? 条件覆盖 Path coverage: is every possible combination of branches — every path through the program — taken by some test case? 路径覆盖 测试效果：路径覆盖&gt;分支覆盖&gt;语句覆盖 测试难度：路径覆盖&gt;分支覆盖&gt;语句覆盖 Automated Testing and Regression Testing 回归测试：一旦程序被修改，重新执行之前的所有测试。 Documenting Your Testing Strategy测试策略（根据什么来选择测试用例）非常重要，需要在程序中显式记录下来 目的：在代码评审过程中，其他人可以理解你的测试，并评判你的测试是否足够充分","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"软件构造的多维度视图和质量目标","slug":"1.软件构造的多维度视图和质量目标","date":"2022-05-08T09:34:00.000Z","updated":"2022-06-14T11:35:12.163Z","comments":true,"path":"2022/05/08/1.软件构造的多维度视图和质量目标/","link":"","permalink":"http://partychicken.github.io/2022/05/08/1.%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E5%A4%9A%E7%BB%B4%E5%BA%A6%E8%A7%86%E5%9B%BE%E5%92%8C%E8%B4%A8%E9%87%8F%E7%9B%AE%E6%A0%87/","excerpt":"","text":"1.软件构造的多维度视图和质量目标Multi-dimensional software viewsConstituents of a software systemSoftware = Program + Data + Documents Software = Modules(Components) + Data/Control Flows 软件的多维视图 Build-time views Code-level view：代码的逻辑组织 Component-level view：代码的物理组织 Moment view：特定时刻的软件形态 Period view：软件随时间的变化 Build-time, moment, and code-level view 词汇层面： 面向词法的源代码 半结构化的源代码：近乎自然语言的风格+遵循特定的编程语法 语法层面：面向语法的程序结构（例子：抽象语法树（AST）） 1234567while (a != b) &#123; if (a &gt; b) a = a - b; else b = b - a;&#125;return a; 语义层面：面向语义的程序结构（例子：类图（Class Diagram）） 用Class Diagram描述接口，类，属性，方法以及他们的关系。 通常是图形化的，在设计阶段被模型化，然后转换成源代码。 由面向对象的分析和设计产生的满足用户需求的结果。 Build-time, period, and code-level view描述“变化”的视图。 代码变化：Lines added, modified or deleted to a file from one version to another. Build-time, moment, and component-level view源代码被物理地组织为文件，文件被目录所组织。 文件被封装成包，在逻辑上被封装成组件和sub-systems。 可复用的模块以库的形式存放。 库：被储存为磁盘文件。开发者像使用编程语言指令一样使用库的功能。来源包括：操作系统、编程语言（SDK）、第三方公司、自己积累。 静态链接：库被拷贝进入代码，执行时无需提供库文件。 Build-time， period， and component-level viewSoftware Configuration Item (SCI，配置项) Version (版本) Version Control System (VCS) Runtime Views 代码层面：逻辑实体在内存中如何 呈现？ 构件层面：物理实体在物理硬件环境中如何呈现？ 逻辑/物理实体 在内存/硬件环境中特定时刻的形态如何？ 逻辑/物理实体在内存/ 硬件环境中的形态随时间如何变化？ 原生机器码：最快的方式（because the program full accesses to the CPU’s features） 动态链接：库文件不会在build阶段被加入可执行软件，仅仅做出标记。运行时根据标记装载至内存。 配置文件和数据文件 分布式程序的运行态：需要多个运行程序，分别部署于多个计算机物理环境。 Run-time, moment, and code-level view Snapshot diagram(代码快照图)：描述程序运行时内存里变量层面的状态。 Memory dump（内存信息转储）:一个储存在硬盘上的文件，是程序运行过程中内存的副本，产生于abort时，可用于分析错误。 Run-time, period, and code-level viewSequence diagram in UML: interactions among program units Execution tracing：用日志方式记录程序执行的调用次序。 Run-time, moment, and component-level viewDeployment diagram in UML Run-time, period, and component-level view系统层面的事件日志：提供给系统管理员一些对诊断和核对有用的信息。 Software construction: Transformation between views Types of Transformations in Software Construction $ \\phi \\to Code $ Programming / Coding (ADT/OOP) $Code \\to Component$ Design(ADT/OOP; Reusability; Maintainability) $Build-time \\to Run-time$ Install / Deploy Debug, unit/integration testing $Moment \\to Period$ Version control Quality properties of software systems External quality factors: 对用户有影响，可被用户检测到的因素（速度，易用性等） Internal quality factors：对软件本身和开发者有影响的要素（可读性，模块化等） 外部质量取决于内部质量 External quality factors1：Correctness按照预先定义的规约执行，是最重要的质量指标 Method测试和调试：发现不正确、消除不正确 防御式编程：在写程序的时候就确保正确性 形式化方法：通过形式化验证发现问题 2：Robustness健壮性(鲁棒性)：针对异常情况的处理。 健壮性是对正确性的补充，对出现规约定义之外的行为时，要求软件做出恰当的反应。（至少不要崩溃） 3：Extendibility对软件的规约进行修改，是否足够容易？ 规模越大，扩展起来越不容易 Two principles are essential for improving extendibility Design simplicity : 简约主义设计 Decentralization : 分离主义设计 4：Reusability一次开发，多次使用。 不要重复造轮子！ 5：Compatibility不同的软件系统之间相互可容易的集成。 兼容性的重要之处在于，软件不是独立运作的，而是需要与其他软件交互的（包括运行环境）。 保持设计的同构性，对兼容性进行标准化。 6：Efficiency性能毫无意义，除非有 足够的正确性。 对性能的关注要与其他质量属性进行折中。 过度的优化导致软件不再适应变化和复用。 7：Portability软件可方便的在不同的技术环境之间移植。（包含硬件和操作系统） 8：Ease of use易用性：容易学、安装、操作、监控。 给用户提供详细的指南。 9：FunctionalityFunctionality is the extent of possibilities provided by a system. Featurism：程序设计中一种不适宜的趋势，即软件开发者增加越来越多的功能，企图跟上竞争，其结果是程序极为复杂、不灵活、占用过多的磁盘空间。 10：TimelinessTimeliness (及时性) is the ability of a software system to be released when or before its users want it. A great software product that appears too late might miss its target altogether. Others Verifiability Integrity Repairability Economy Internal quality factors Readability Understandability Clearness Size Tradeoff between quality properties Integrity $\\Longleftrightarrow$ Ease of use Economy $\\Longleftrightarrow$ Functionality, (reusability) Efficiency $\\Longleftrightarrow$ Portability, reusability Timeliness(“Rapid Application Development”) $\\Longleftrightarrow$ Extendibility How OOP improves quality Correctness: encapsulation, decentralization Robustness: encapsulation, error handling Extendibility: encapsulation, information hiding Reusability: modularity, component, models, patterns Compatibility: standardized module and interface Portability: information hiding, abstraction Ease of use: GUI components, framework Efficiency: reusable components Timeliness: modeling, reuse Economy: reuse Functionality: extendibility Five key quality objectives of software construction Easy to understand: elegant and beautiful code / understandability Ready for change: maintainability and adaptability Cheap for develop: design for/with reuse: reusability Safe from bugs: robustness Efficient to run: performance","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"Java学习笔记","slug":"Java 学习笔记","date":"2022-04-30T09:34:00.000Z","updated":"2022-06-14T11:34:33.461Z","comments":true,"path":"2022/04/30/Java 学习笔记/","link":"","permalink":"http://partychicken.github.io/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Java 学习笔记基础篇 Java是面向对象的语言。 Java是解释型的。 对象和类标准操作流程123456/* 实例化对象 */Object referenceVariable = new Constructor();/* 访问类中的变量 */referenceVariable.variableName;/* 访问类中的方法 */referenceVariable.methodName(); 需要注意的规则 一个源文件中只能有一个 public 类 一个源文件可以有多个非 public 类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 包包主要用来对类和接口进行分类。 importimport 可以提供一个路径，使得编译器找到路径下的所有类 数据类型仅记录与 C++ 差别较大的 byte8位有符号整数（-128~127） float&amp;double字面值的形式为：0.0f / 0.0d boolean比 bool 难打捏（哭 char16位 Unicode 字符，最小值为 \\u0000 ,最大值为 \\uffff Strings 要大写捏 包装类名称：Boolean Byte Short Integer Long Float Double Character 可调用的值：.SIZE .MAX_VALUE .MIN_VALUE 常量使用 final 关键字进行修饰 变量类型Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 局部变量 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。 类变量 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 访问修饰 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 运算符只列出与 C++ 不同的部分 &gt;&gt;&gt;右移补零，暂时不知道与普通右移的区别 instanceof判断一个变量是否是某类型的，比如 12String name = &quot;Jiaran&quot;;boolean result = name instanceof String 优先级常用的和 C++ 相同，位运算无脑加括号就完了 循环/条件结构与 C++ 同，支持 for(int x : number)","categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}],"tags":[]},{"title":"CCPC2020 Weihai E","slug":"E","date":"2022-04-20T03:08:41.000Z","updated":"2022-04-22T12:48:30.796Z","comments":true,"path":"2022/04/20/E/","link":"","permalink":"http://partychicken.github.io/2022/04/20/E/","excerpt":"","text":"问题描述在游戏“炉石传说”中，存在一张卡牌”考古专家雷诺”，其在特定条件下会对敌方所有随从随机地进行总量为10点的伤害。而其随机方式是对于每一点伤害依次进行判定，等概率地从所有敌方的存活随从中选择一个进行伤害。我们关注于对于某特定随从序列其杀死随从数量的期望，并将其伤害从常数 $10$ 推广到某一给定数值 $m$，得到如下问题： 对某一正项序列 $a_1,a_2,\\cdots,a_n$ ,依次进行 $m$ 次操作，每次在所有非零项 $a_{p_1},a_{p_2}, \\cdots,a_{p_m}$ 中等概率地选取一个数 $a_{p_i}$ 并令 $a_{p_i}=a_{p_i}-1$ 。记 $m$ 次后的非零项个数为 $x$ ,求 $x$ 的期望 $E(x)$. 问题解法定义 $S_l= \\{s_1,s_2,\\cdots,s_l \\}$ 表示一个长度为 $l$ 的操作序列，其中，$s_i \\in[1,n]$ 表示第 $i$ 次操作选取了 $a_{s_i}$ . 令 $ \\sigma_i^{S_l}$ 表示经 $S_l$ 的前 $i$ 次操作后，序列 $ \\{a_i\\}$ 剩余的非零项的个数。特别地，令 $ \\sigma^{S_l}= \\sigma_l^{S_l}$ 表示经过全部 $S_l$ 的操作后，其非零项的个数。 那么，每个合法操作序列出现的概率 P(S_l)=\\prod_{k=1}^{l}\\dfrac{1}{\\sigma_{i}^{S_l}}定义 $\\Gamma$ 为所有长度为 $m$ 的合法操作序列的集合，则 E(x)=\\sum_{S_m\\in \\Gamma}P(S_m)(n-\\sigma^{S_m})接下来，我们将问题的求解分为两个步骤。 Part I定义集合 $\\Gamma_{l,Set}$ $0 \\le l \\le m,Set \\subseteq [n]$ 是序列 $S= \\{s_1,s_2, \\cdots,s_n \\}$ 的集合，要求序列满足： $ \\forall 1 \\le i \\le n,s_i=0 || s_i \\in Set$ $ \\forall j \\in S,cnt_j(Set)=a_j$ 其中，$s_i=0$ 代表第 $i$ 次操作的对象 $\\notin Set$ , $cnt_i(S)$ 表示序列 $S$ 中 $i$ 的出现次数 设 $f_{l,Set} (0 \\le l \\le m,Set \\subseteq [n])$ 为 f_{l,Set}=\\sum_{s \\in \\Gamma_{l,Set}} p(s)则有, f_{0,\\emptyset}=1 f_{l,Set}=\\dfrac{1}{n-|Set|}f_{l-1,Set}+ \\sum_{i \\in Set} \\dfrac{1}{n-|Set-\\{i\\}|} f_{l-1,Set-\\{i\\}} \\times \\binom{l-sum(Set-\\{i\\})-1}{a_i-1}其中, sum(A)=\\sum_{i \\in A} a_i递推式中的第一项表示 $s_l=0$ 的概率,后面则是枚举 $s_l=i$ 且 $cnt_i(S)=a_i$ 的概率,将这两类情况求和,即为满足条件的总概率. 可以通过预处理所有的 $sum(A)$ 以及 $|A|$ 使这个递推式可以在 $O(nm2^n)$ 的时间内完成. Part II可以发现,$ \\forall S \\in \\Gamma_{m,Set},cnt_0(S)$ 恒定,所以只需考虑 $s_i=0$ 的位置,给每个位置赋上不属于 $Set$ 的值,并且满足$ \\forall i \\notin Set,cnt_i(S)&lt;a_i$ 即可得到一个合法的序列.记这样的方案总数为 $g_{Set}$,则有: ans=\\sum f_{m,Set} \\cdot g_{Set} \\cdot |Set|令 $h_{l,Set}$,表示序列 $S’= \\{s_1,s_2,\\cdots,s_l\\}$ 满足: $\\forall 1 \\le i \\le l,s_i \\in Set $ $\\forall i \\in Set,cnt_i(S’)&lt;a_i $ 的个数,则 $h_{m-|Set|,Set}=g_{Set^{C}}$,所以只要求得 $h_{i,Set}$ 序列即可. 易得递推式 h_{i,Set}=\\sum_{k=0}^{\\min\\{i,a_{low(Set)}-1\\}}h_{i-k,Set-{low(Set)}} \\cdot \\binom{i}{k}其中,$low(Set)$,表示 $Set$ 中的最小元素. 上述递推可以在 $O(m^2 2^n)$ 的时间内完成. 综上,问题得解.总时间复杂度为 $O(m(n+m)2^n)$. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=5e4+100;double fac[MAXN],fav[MAXN],dp[110][MAXN],fir[MAXN][110];int n,m,dat[MAXN],sum[MAXN],num[MAXN],lower[MAXN];double qpow(double base,int tim)&#123; double ans=1; while(tim) &#123; if(tim&amp;1) ans*=base; base*=base;tim&gt;&gt;=1; &#125; return ans;&#125;void init()&#123; fac[0]=fac[1]=1; fav[0]=fav[1]=1; for(int i=2;i&lt;=MAXN-100;i++) &#123; fac[i]=fac[i-1]*i; fav[i]=fav[i-1]/i; &#125;&#125;double C(int a,int b)&#123; return fac[b]*fav[a]*fav[b-a];&#125;double get_dp(int x,int res)&#123; if(fir[x][res]&gt;(1e-8)) return fir[x][res]; int now=lower[x]; if(res==0) fir[x][res]=1; else for(int i=0;i&lt;=dat[now]-1;i++) fir[x][res]+=get_dp(x^(1&lt;&lt;now-1),res-i)*C(i,res); //cout&lt;&lt;&quot;!!!!&quot;&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;&quot; &quot;&lt;&lt;fir[x][res]&lt;&lt;endl; return fir[x][res];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m;init(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;dat[i]); for(int i=0;i&lt;(1&lt;&lt;n);i++) for(int j=1;j&lt;=n;j++) if(i&amp;(1&lt;&lt;(j-1))) &#123; if(lower[i]==0) lower[i]=j; else lower[i]=min(lower[i],j); num[i]++; sum[i]+=dat[j]; &#125; if(sum[(1&lt;&lt;n)-1]==m) &#123; printf(&quot;%d&quot;,n); return 0; &#125; dp[0][0]=1; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) &#123; if(sum[j]&gt;i) continue; //cout&lt;&lt;num[(1&lt;&lt;n)-1]&lt;&lt;&quot; &quot;&lt;&lt;(n-num[j])&lt;&lt;endl; if(i&gt;sum[(1&lt;&lt;n)-1]-(n-num[j])) continue; dp[i][j]=dp[i-1][j]/(n-num[j]); for(int k=1;k&lt;=n;k++) if(j&amp;(1&lt;&lt;(k-1))) &#123; double p=1.0/(n-num[j^(1&lt;&lt;(k-1))]);int res=i-sum[j^(1&lt;&lt;(k-1))]; dp[i][j]+=dp[i-1][j^(1&lt;&lt;(k-1))]*C(dat[k]-1,res-1)*p; &#125; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;dp[i][j]&lt;&lt;endl; &#125;// for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++)// printf(&quot;%.3lf &quot;,dp[m][i]);// cout&lt;&lt;endl; fir[0][0]=1; for(int i=0;i&lt;1&lt;&lt;n;i++) &#123; int now=lower[i]; for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=min(dat[now]-1,j);k++) fir[i][j]+=fir[i^(1&lt;&lt;(now-1))][j-k]*C(k,j); &#125; double ans=0;int base=(1&lt;&lt;n)-1; for(int i=0;i&lt;(1&lt;&lt;n);i++) if(m&gt;=sum[i]&amp;&amp;fir[base^i][m-sum[i]]!=0) ans+=num[i]*dp[m][i]*fir[base^i][m-sum[i]]; printf(&quot;%.10lf \\n&quot;,ans);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://partychicken.github.io/categories/ACM/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://partychicken.github.io/tags/dp/"},{"name":"期望","slug":"期望","permalink":"http://partychicken.github.io/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"基础数论总结","slug":"数论","date":"2022-04-20T03:08:41.000Z","updated":"2022-04-22T13:11:50.828Z","comments":true,"path":"2022/04/20/数论/","link":"","permalink":"http://partychicken.github.io/2022/04/20/%E6%95%B0%E8%AE%BA/","excerpt":"","text":"GCD&amp;LCM辗转相除求gcd$gcd(x,y)=gcd(y,x\\%y)$ ，易证。 12345int gcd(int x,int y)&#123; if(!y) return x; return gcd(y,x%y);&#125; 求lcm lcm(x,y) \\times gcd(x,y)=x \\times y lcm(x,y)=\\dfrac{x\\times y}{gcd(x,y)}证明： 设 $x=p\\times a$ , $y=p \\times b$ 且$gcd(a,b)=1$ 则有 $gcd(x,y)=p,lcm(x,y)=lcm(a,b)\\times p$ $a,b$ 互质 ，故 $lcm(a,b)=a\\times b ,lcm(x,y)=a\\times b\\times p$ 证毕 扩展欧几里德 ExGCD用于求方程 $ax+by=gcd(a,b)$ 的一组解 1234567891011121314int exgcd(int x,int y,int &amp;a,int &amp;b)&#123; if(!y) &#123; a=1; b=0; return x; &#125; int res=exgcd(y,x%y,a,b); int tmp=a; a=b; b=tmp-(x/y)*b; return res;&#125; 注意：代码里的 $x,y,a,b$ 与我所述的是反的 证明： 在 $ax+by=gcd(a,b)$ 中， 当 $b=0$ 时， \\begin{cases} x=1 \\\\ y=0 \\end{cases}显然为方程的一组合法解。 已知 $bx+(a\\%b)y=gcd(b,a\\%b)$ 的解，考虑向 $ax’+by’=gcd(a,b)$ 的解转移 由于 a\\%b=a-\\lfloor\\dfrac{a}{b}\\rfloor\\times b所以可得方程 bx+(a-\\lfloor\\dfrac{a}{b}\\rfloor\\times b)y=ax'+by' bx+ay-\\lfloor\\dfrac{a}{b}\\rfloor\\times by=ax'+by' ay+b(x-\\lfloor\\dfrac{a}{b}\\rfloor\\times y)=ax'+by'显然一组可行解为 \\begin{cases} x'=y\\\\ y'=x-\\lfloor \\dfrac{a}{b} \\rfloor \\times y \\end{cases}证毕 ExGCD求$ax+by=1$用ExGCD解出$ax’+by’=gcd(a,b)$的一组解后 由 \\dfrac {ax'}{gcd(a,b)}+\\dfrac{by'}{gcd(a,b)}=1可得 \\begin{cases} x=\\dfrac{x'}{gcd(a,b)}\\\\ y=\\dfrac{y'}{gcd(a,b)} \\end{cases}求得$ax+by=1$的一组解后，可由一组解扩展出所有解 显然 a(x+k\\times b)+b(y-k\\times a)=1则 \\begin{cases} x=\\dfrac{x'}{gcd(a,b)}+k\\times b\\\\ y=\\dfrac{y'}{gcd(a,b)}-k\\times a \\end{cases}为$ax+by=1$的解的通项 费马小定理如果$p$是质数，且$a$与$p$互质，则有： a^{p-1}\\equiv 1(mod\\;p)欧拉定理 a^{\\varphi(p)}\\equiv 1(mod\\;p)乘法逆元定义如果 $ab\\equiv 1(mod\\;p)$ ,则 $a,b$ 互为 $mod\\;p$ 意义下的乘法逆元 说明：众所周知，除法是不可膜的。而乘法逆元是为了使除法可膜而诞生的。即$ \\dfrac a b\\equiv a\\times inv(b)(mod\\;p)$，其中$a$为任意整数。化简可得，$b\\times inv(b)\\equiv1(mod\\;p)$ 求法费马小定理可用于解决膜数$p$为质数的情况 a^{p-1}\\equiv 1(mod\\;p)a\\times a^{p-2}\\equiv 1(mod\\;p)则$a^{p-2}$即为$a\\;mod\\;p$意义下的逆元，快速幂可求 欧拉定理可用于解决膜数$p$不为质数的情况 a^{\\varphi(p)}\\equiv 1(mod\\;p)a\\times a^{\\varphi(p)-1}\\equiv 1(mod\\;p)则$a^{\\varphi(p)-1}$即为$a\\;mod\\;p$意义下的逆元，快速幂可求 ExGCD由 a\\times inv(a)\\equiv 1(mod\\;p)可得 a\\times inv(a)+p\\times y=1Exgcd可求得解 顺便记录一下自己的智障问题：这样不是会求出很多解吗？答：$inv(a)$的所有解都是$inv(a)+k\\times p$,$mod\\;p$之后都是一样的 线性递推inv(i)=-(p/i)*inv(p\\%i)证明： 设$A=\\lfloor\\dfrac p i\\rfloor,B=p\\%i$,则$A\\times i+B=p$。 则有 A\\times i+B\\equiv 0(mod\\;p)i\\equiv-\\dfrac{B}{A}(mod\\;p)i^{-1}\\equiv-A\\times B^{-1}即 inv(i)=-(p/i)\\times inv(p\\%i)阶乘逆元可以$O(n)$求出$1!\\cdots n!$的逆元，组合数常用 a!\\times inv(a!)\\equiv1(mod\\;p)(a-1)!\\times (a\\times inv(a!))\\equiv1(mod\\;p)则 inv((a-1)!)=a\\times inv(a!)可以先求出$inv(a!)$,然后推出所有阶乘的逆元 中国剩余定理 CRT设$m_1,m_2,\\ldots,m_k$两两互素，则同余方程组 \\begin{cases}x \\equiv a_1(mod\\;m_1) \\\\x \\equiv a_2(mod\\;m_2) \\\\\\qquad\\dots \\\\x \\equiv a_k(mod\\;m_k)\\end{cases}有整数解; 并且在$mod\\;M=\\prod_{i=1}^{k}m_i$意义下有唯一解，为 x\\equiv \\sum_{i=1}^ka_iM_iinv(M_i)\\%M其中$M_i=\\dfrac{M}{m_i}$,$inv(M_i)$为$M_i\\;mod\\;m_i$意义下的逆元 扩展中国剩余定理 exCRT解同余方程 \\begin{cases}x \\equiv a_1(mod\\;m_1) \\\\x \\equiv a_2(mod\\;m_2) \\\\\\qquad\\dots \\\\x \\equiv a_k(mod\\;m_k)\\end{cases}假设我们已经解出了前 $k-1$ 组解 $x_{k-1}$，那么 $x_k$ 一定为 $x_{k-1}+t\\times LCM(m_1,m_2,\\cdots m_{k-1})$。 则有 x_{k-1}+t\\times LCM(m_1,m_2,\\cdots m_{k-1})\\equiv a_k(mod\\;m_k)用 exgcd 解同余方程即可。 扩展欧拉定理 a^b\\equiv a^{b\\%\\varphi(n)+\\varphi(n)}(mod\\;n)","categories":[{"name":"ACM","slug":"ACM","permalink":"http://partychicken.github.io/categories/ACM/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://partychicken.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"test","slug":"test","date":"2022-04-18T08:29:06.000Z","updated":"2022-04-22T11:30:24.308Z","comments":true,"path":"2022/04/18/test/","link":"","permalink":"http://partychicken.github.io/2022/04/18/test/","excerpt":"","text":"Successfully build the blog私は20歳で、学生です","categories":[],"tags":[]}],"categories":[{"name":"软件构造","slug":"软件构造","permalink":"http://partychicken.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"},{"name":"ICS","slug":"ICS","permalink":"http://partychicken.github.io/categories/ICS/"},{"name":"ACM","slug":"ACM","permalink":"http://partychicken.github.io/categories/ACM/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://partychicken.github.io/tags/dp/"},{"name":"期望","slug":"期望","permalink":"http://partychicken.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"数论","slug":"数论","permalink":"http://partychicken.github.io/tags/%E6%95%B0%E8%AE%BA/"}]}