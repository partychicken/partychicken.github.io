{"meta":{"title":"PC 的 blog","subtitle":"","description":"","author":"partychicken","url":"http://partychicken.github.io","root":"/"},"pages":[{"title":"links","date":"2020-04-22T12:46:25.000Z","updated":"2022-04-22T11:58:59.180Z","comments":true,"path":"PY.html","permalink":"http://partychicken.github.io/PY.html","excerpt":"","text":""}],"posts":[{"title":"CCPC2020 Weihai E","slug":"E","date":"2022-04-20T03:08:41.000Z","updated":"2022-04-22T12:42:18.913Z","comments":true,"path":"2022/04/20/E/","link":"","permalink":"http://partychicken.github.io/2022/04/20/E/","excerpt":"","text":"问题描述在游戏“炉石传说”中，存在一张卡牌”考古专家雷诺”，其在特定条件下会对敌方所有随从随机地进行总量为10点的伤害。而其随机方式是对于每一点伤害依次进行判定，等概率地从所有敌方的存活随从中选择一个进行伤害。我们关注于对于某特定随从序列其杀死随从数量的期望，并将其伤害从常数 $10$ 推广到某一给定数值 $m$，得到如下问题： 对某一正项序列 $a_1,a_2,\\cdots,a_n$ ,依次进行 $m$ 次操作，每次在所有非零项 $a_{p_1},a_{p_2}, \\cdots,a_{p_m}$ 中等概率地选取一个数 $a_{p_i}$ 并令 $a_{p_i}=a_{p_i}-1$ 。记 $m$ 次后的非零项个数为 $x$ ,求 $x$ 的期望 $E(x)$. 问题解法定义 $S_l= \\{s_1,s_2,\\cdots,s_l \\}$ 表示一个长度为 $l$ 的操作序列，其中，$s_i \\in[1,n]$ 表示第 $i$ 次操作选取了 $a_{s_i}$ . 令 $ \\sigma_i^{S_l}$ 表示经 $S_l$ 的前 $i$ 次操作后，序列 $ \\{a_i\\}$ 剩余的非零项的个数。特别地，令 $ \\sigma^{S_l}= \\sigma_l^{S_l}$ 表示经过全部 $S_l$ 的操作后，其非零项的个数。 那么，每个合法操作序列出现的概率 P(S_l)=\\prod_{k=1}^{l}\\dfrac{1}{\\sigma_{i}^{S_l}}定义 $\\Gamma$ 为所有长度为 $m$ 的合法操作序列的集合，则 E(x)=\\sum_{S_m\\in \\Gamma}P(S_m)(n-\\sigma^{S_m})接下来，我们将问题的求解分为两个步骤。 Part I定义集合 $\\Gamma_{l,Set}$ $0 \\le l \\le m,Set \\subseteq [n]$ 是序列 $S= \\{s_1,s_2, \\cdots,s_n \\}$ 的集合，要求序列满足： $ \\forall 1 \\le i \\le n,s_i=0 || s_i \\in Set$ $ \\forall j \\in S,cnt_j(Set)=a_j$ 其中，$s_i=0$ 代表第 $i$ 次操作的对象 $\\notin Set$ , $cnt_i(S)$ 表示序列 $S$ 中 $i$ 的出现次数 设 $f_{l,Set} (0 \\le l \\le m,Set \\subseteq [n])$ 为 f_{l,Set}=\\sum_{s \\in \\Gamma_{l,Set}} p(s)则有, f_{0,\\emptyset}=1 f_{l,Set}=\\dfrac{1}{n-|Set|}f_{l-1,Set}+ \\sum_{i \\in Set} \\dfrac{1}{n-|Set-\\{i\\}|} f_{l-1,Set-\\{i\\}} \\times \\binom{l-sum(Set-\\{i\\})-1}{a_i-1}其中, sum(A)=\\sum_{i \\in A} a_i递推式中的第一项表示 $s_l=0$ 的概率,后面则是枚举 $s_l=i$ 且 $cnt_i(S)=a_i$ 的概率,将这两类情况求和,即为满足条件的总概率. 可以通过预处理所有的 $sum(A)$ 以及 $|A|$ 使这个递推式可以在 $O(nm2^n)$ 的时间内完成. Part II可以发现,$ \\forall S \\in \\Gamma_{m,Set},cnt_0(S)$ 恒定,所以只需考虑 $s_i=0$ 的位置,给每个位置赋上不属于 $Set$ 的值,并且满足$ \\forall i \\notin Set,cnt_i(S)&lt;a_i$ 即可得到一个合法的序列.记这样的方案总数为 $g_{Set}$,则有: ans=\\sum f_{m,Set} \\cdot g_{Set} \\cdot |Set|令 $h_{l,Set}$,表示序列 $S’= \\{s_1,s_2,\\cdots,s_l\\}$ 满足: $\\forall 1 \\le i \\le l,s_i \\in Set $ $\\forall i \\in Set,cnt_i(S’)&lt;a_i $ 的个数,则 $h_{m-|Set|,Set}=g_{Set^{C}}$,所以只要求得 $h_{i,Set}$ 序列即可. 易得递推式 h_{i,Set}=\\sum_{k=0}^{\\min\\{i,a_{low(Set)}-1\\}}h_{i-k,Set-{low(Set)}} \\cdot \\binom{i}{k}其中,$low(Set)$,表示 $Set$ 中的最小元素. 上述递推可以在 $O(m^2 2^n)$ 的时间内完成. 综上,问题得解.总时间复杂度为 $O(m(n+m)2^n)$. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=5e4+100;double fac[MAXN],fav[MAXN],dp[110][MAXN],fir[MAXN][110];int n,m,dat[MAXN],sum[MAXN],num[MAXN],lower[MAXN];double qpow(double base,int tim)&#123; double ans=1; while(tim) &#123; if(tim&amp;1) ans*=base; base*=base;tim&gt;&gt;=1; &#125; return ans;&#125;void init()&#123; fac[0]=fac[1]=1; fav[0]=fav[1]=1; for(int i=2;i&lt;=MAXN-100;i++) &#123; fac[i]=fac[i-1]*i; fav[i]=fav[i-1]/i; &#125;&#125;double C(int a,int b)&#123; return fac[b]*fav[a]*fav[b-a];&#125;double get_dp(int x,int res)&#123; if(fir[x][res]&gt;(1e-8)) return fir[x][res]; int now=lower[x]; if(res==0) fir[x][res]=1; else for(int i=0;i&lt;=dat[now]-1;i++) fir[x][res]+=get_dp(x^(1&lt;&lt;now-1),res-i)*C(i,res); //cout&lt;&lt;&quot;!!!!&quot;&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;&quot; &quot;&lt;&lt;fir[x][res]&lt;&lt;endl; return fir[x][res];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m;init(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;dat[i]); for(int i=0;i&lt;(1&lt;&lt;n);i++) for(int j=1;j&lt;=n;j++) if(i&amp;(1&lt;&lt;(j-1))) &#123; if(lower[i]==0) lower[i]=j; else lower[i]=min(lower[i],j); num[i]++; sum[i]+=dat[j]; &#125; if(sum[(1&lt;&lt;n)-1]==m) &#123; printf(&quot;%d&quot;,n); return 0; &#125; dp[0][0]=1; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) &#123; if(sum[j]&gt;i) continue; //cout&lt;&lt;num[(1&lt;&lt;n)-1]&lt;&lt;&quot; &quot;&lt;&lt;(n-num[j])&lt;&lt;endl; if(i&gt;sum[(1&lt;&lt;n)-1]-(n-num[j])) continue; dp[i][j]=dp[i-1][j]/(n-num[j]); for(int k=1;k&lt;=n;k++) if(j&amp;(1&lt;&lt;(k-1))) &#123; double p=1.0/(n-num[j^(1&lt;&lt;(k-1))]);int res=i-sum[j^(1&lt;&lt;(k-1))]; dp[i][j]+=dp[i-1][j^(1&lt;&lt;(k-1))]*C(dat[k]-1,res-1)*p; &#125; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;dp[i][j]&lt;&lt;endl; &#125;// for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++)// printf(&quot;%.3lf &quot;,dp[m][i]);// cout&lt;&lt;endl; fir[0][0]=1; for(int i=0;i&lt;1&lt;&lt;n;i++) &#123; int now=lower[i]; for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=min(dat[now]-1,j);k++) fir[i][j]+=fir[i^(1&lt;&lt;(now-1))][j-k]*C(k,j); &#125; double ans=0;int base=(1&lt;&lt;n)-1; for(int i=0;i&lt;(1&lt;&lt;n);i++) if(m&gt;=sum[i]&amp;&amp;fir[base^i][m-sum[i]]!=0) ans+=num[i]*dp[m][i]*fir[base^i][m-sum[i]]; printf(&quot;%.10lf \\n&quot;,ans);&#125;","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://partychicken.github.io/tags/dp/"},{"name":"期望","slug":"期望","permalink":"http://partychicken.github.io/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"test","slug":"test","date":"2022-04-18T08:29:06.000Z","updated":"2022-04-22T11:30:24.308Z","comments":true,"path":"2022/04/18/test/","link":"","permalink":"http://partychicken.github.io/2022/04/18/test/","excerpt":"","text":"Successfully build the blog私は20歳で、学生です","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"http://partychicken.github.io/tags/dp/"},{"name":"期望","slug":"期望","permalink":"http://partychicken.github.io/tags/%E6%9C%9F%E6%9C%9B/"}]}