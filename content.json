{"meta":{"title":"PC 的 blog","subtitle":"","description":"","author":"partychicken","url":"http://partychicken.github.io","root":"/"},"pages":[{"title":"links","date":"2020-04-22T12:46:25.000Z","updated":"2022-04-22T11:58:59.180Z","comments":true,"path":"PY.html","permalink":"http://partychicken.github.io/PY.html","excerpt":"","text":""}],"posts":[{"title":"HIT ICS 大作业","slug":"ics","date":"2022-05-19T14:14:00.000Z","updated":"2022-05-19T14:18:09.286Z","comments":true,"path":"2022/05/19/ics/","link":"","permalink":"http://partychicken.github.io/2022/05/19/ics/","excerpt":"","text":"","categories":[{"name":"ICS","slug":"ICS","permalink":"http://partychicken.github.io/categories/ICS/"}],"tags":[]},{"title":"Java学习笔记","slug":"Java 学习笔记","date":"2022-04-30T09:34:00.000Z","updated":"2022-05-02T09:35:42.245Z","comments":true,"path":"2022/04/30/Java 学习笔记/","link":"","permalink":"http://partychicken.github.io/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Java 学习笔记基础篇 Java是面向对象的语言。 Java是解释型的。 对象和类标准操作流程123456/* 实例化对象 */Object referenceVariable = new Constructor();/* 访问类中的变量 */referenceVariable.variableName;/* 访问类中的方法 */referenceVariable.methodName(); 需要注意的规则 一个源文件中只能有一个 public 类 一个源文件可以有多个非 public 类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 包包主要用来对类和接口进行分类。 importimport 可以提供一个路径，使得编译器找到路径下的所有类 数据类型仅记录与 C++ 差别较大的 byte8位有符号整数（-128~127） float&amp;double字面值的形式为：0.0f / 0.0d boolean比 bool 难打捏（哭 char16位 Unicode 字符，最小值为 \\u0000 ,最大值为 \\uffff Strings 要大写捏 包装类名称：Boolean Byte Short Integer Long Float Double Character 可调用的值：.SIZE .MAX_VALUE .MIN_VALUE 常量使用 final 关键字进行修饰 变量类型Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 局部变量 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。 类变量 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 访问修饰 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 运算符只列出与 C++ 不同的部分 &gt;&gt;&gt;右移补零，暂时不知道与普通右移的区别 instanceof判断一个变量是否是某类型的，比如 12String name = &quot;Jiaran&quot;;boolean result = name instanceof String 优先级常用的和 C++ 相同，位运算无脑加括号就完了 循环/条件结构与 C++ 同，支持 for(int x : number)","categories":[],"tags":[]},{"title":"CCPC2020 Weihai E","slug":"E","date":"2022-04-20T03:08:41.000Z","updated":"2022-04-22T12:48:30.796Z","comments":true,"path":"2022/04/20/E/","link":"","permalink":"http://partychicken.github.io/2022/04/20/E/","excerpt":"","text":"问题描述在游戏“炉石传说”中，存在一张卡牌”考古专家雷诺”，其在特定条件下会对敌方所有随从随机地进行总量为10点的伤害。而其随机方式是对于每一点伤害依次进行判定，等概率地从所有敌方的存活随从中选择一个进行伤害。我们关注于对于某特定随从序列其杀死随从数量的期望，并将其伤害从常数 $10$ 推广到某一给定数值 $m$，得到如下问题： 对某一正项序列 $a_1,a_2,\\cdots,a_n$ ,依次进行 $m$ 次操作，每次在所有非零项 $a_{p_1},a_{p_2}, \\cdots,a_{p_m}$ 中等概率地选取一个数 $a_{p_i}$ 并令 $a_{p_i}=a_{p_i}-1$ 。记 $m$ 次后的非零项个数为 $x$ ,求 $x$ 的期望 $E(x)$. 问题解法定义 $S_l= \\{s_1,s_2,\\cdots,s_l \\}$ 表示一个长度为 $l$ 的操作序列，其中，$s_i \\in[1,n]$ 表示第 $i$ 次操作选取了 $a_{s_i}$ . 令 $ \\sigma_i^{S_l}$ 表示经 $S_l$ 的前 $i$ 次操作后，序列 $ \\{a_i\\}$ 剩余的非零项的个数。特别地，令 $ \\sigma^{S_l}= \\sigma_l^{S_l}$ 表示经过全部 $S_l$ 的操作后，其非零项的个数。 那么，每个合法操作序列出现的概率 P(S_l)=\\prod_{k=1}^{l}\\dfrac{1}{\\sigma_{i}^{S_l}}定义 $\\Gamma$ 为所有长度为 $m$ 的合法操作序列的集合，则 E(x)=\\sum_{S_m\\in \\Gamma}P(S_m)(n-\\sigma^{S_m})接下来，我们将问题的求解分为两个步骤。 Part I定义集合 $\\Gamma_{l,Set}$ $0 \\le l \\le m,Set \\subseteq [n]$ 是序列 $S= \\{s_1,s_2, \\cdots,s_n \\}$ 的集合，要求序列满足： $ \\forall 1 \\le i \\le n,s_i=0 || s_i \\in Set$ $ \\forall j \\in S,cnt_j(Set)=a_j$ 其中，$s_i=0$ 代表第 $i$ 次操作的对象 $\\notin Set$ , $cnt_i(S)$ 表示序列 $S$ 中 $i$ 的出现次数 设 $f_{l,Set} (0 \\le l \\le m,Set \\subseteq [n])$ 为 f_{l,Set}=\\sum_{s \\in \\Gamma_{l,Set}} p(s)则有, f_{0,\\emptyset}=1 f_{l,Set}=\\dfrac{1}{n-|Set|}f_{l-1,Set}+ \\sum_{i \\in Set} \\dfrac{1}{n-|Set-\\{i\\}|} f_{l-1,Set-\\{i\\}} \\times \\binom{l-sum(Set-\\{i\\})-1}{a_i-1}其中, sum(A)=\\sum_{i \\in A} a_i递推式中的第一项表示 $s_l=0$ 的概率,后面则是枚举 $s_l=i$ 且 $cnt_i(S)=a_i$ 的概率,将这两类情况求和,即为满足条件的总概率. 可以通过预处理所有的 $sum(A)$ 以及 $|A|$ 使这个递推式可以在 $O(nm2^n)$ 的时间内完成. Part II可以发现,$ \\forall S \\in \\Gamma_{m,Set},cnt_0(S)$ 恒定,所以只需考虑 $s_i=0$ 的位置,给每个位置赋上不属于 $Set$ 的值,并且满足$ \\forall i \\notin Set,cnt_i(S)&lt;a_i$ 即可得到一个合法的序列.记这样的方案总数为 $g_{Set}$,则有: ans=\\sum f_{m,Set} \\cdot g_{Set} \\cdot |Set|令 $h_{l,Set}$,表示序列 $S’= \\{s_1,s_2,\\cdots,s_l\\}$ 满足: $\\forall 1 \\le i \\le l,s_i \\in Set $ $\\forall i \\in Set,cnt_i(S’)&lt;a_i $ 的个数,则 $h_{m-|Set|,Set}=g_{Set^{C}}$,所以只要求得 $h_{i,Set}$ 序列即可. 易得递推式 h_{i,Set}=\\sum_{k=0}^{\\min\\{i,a_{low(Set)}-1\\}}h_{i-k,Set-{low(Set)}} \\cdot \\binom{i}{k}其中,$low(Set)$,表示 $Set$ 中的最小元素. 上述递推可以在 $O(m^2 2^n)$ 的时间内完成. 综上,问题得解.总时间复杂度为 $O(m(n+m)2^n)$. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=5e4+100;double fac[MAXN],fav[MAXN],dp[110][MAXN],fir[MAXN][110];int n,m,dat[MAXN],sum[MAXN],num[MAXN],lower[MAXN];double qpow(double base,int tim)&#123; double ans=1; while(tim) &#123; if(tim&amp;1) ans*=base; base*=base;tim&gt;&gt;=1; &#125; return ans;&#125;void init()&#123; fac[0]=fac[1]=1; fav[0]=fav[1]=1; for(int i=2;i&lt;=MAXN-100;i++) &#123; fac[i]=fac[i-1]*i; fav[i]=fav[i-1]/i; &#125;&#125;double C(int a,int b)&#123; return fac[b]*fav[a]*fav[b-a];&#125;double get_dp(int x,int res)&#123; if(fir[x][res]&gt;(1e-8)) return fir[x][res]; int now=lower[x]; if(res==0) fir[x][res]=1; else for(int i=0;i&lt;=dat[now]-1;i++) fir[x][res]+=get_dp(x^(1&lt;&lt;now-1),res-i)*C(i,res); //cout&lt;&lt;&quot;!!!!&quot;&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;&quot; &quot;&lt;&lt;fir[x][res]&lt;&lt;endl; return fir[x][res];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m;init(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;dat[i]); for(int i=0;i&lt;(1&lt;&lt;n);i++) for(int j=1;j&lt;=n;j++) if(i&amp;(1&lt;&lt;(j-1))) &#123; if(lower[i]==0) lower[i]=j; else lower[i]=min(lower[i],j); num[i]++; sum[i]+=dat[j]; &#125; if(sum[(1&lt;&lt;n)-1]==m) &#123; printf(&quot;%d&quot;,n); return 0; &#125; dp[0][0]=1; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) &#123; if(sum[j]&gt;i) continue; //cout&lt;&lt;num[(1&lt;&lt;n)-1]&lt;&lt;&quot; &quot;&lt;&lt;(n-num[j])&lt;&lt;endl; if(i&gt;sum[(1&lt;&lt;n)-1]-(n-num[j])) continue; dp[i][j]=dp[i-1][j]/(n-num[j]); for(int k=1;k&lt;=n;k++) if(j&amp;(1&lt;&lt;(k-1))) &#123; double p=1.0/(n-num[j^(1&lt;&lt;(k-1))]);int res=i-sum[j^(1&lt;&lt;(k-1))]; dp[i][j]+=dp[i-1][j^(1&lt;&lt;(k-1))]*C(dat[k]-1,res-1)*p; &#125; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;dp[i][j]&lt;&lt;endl; &#125;// for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++)// printf(&quot;%.3lf &quot;,dp[m][i]);// cout&lt;&lt;endl; fir[0][0]=1; for(int i=0;i&lt;1&lt;&lt;n;i++) &#123; int now=lower[i]; for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=min(dat[now]-1,j);k++) fir[i][j]+=fir[i^(1&lt;&lt;(now-1))][j-k]*C(k,j); &#125; double ans=0;int base=(1&lt;&lt;n)-1; for(int i=0;i&lt;(1&lt;&lt;n);i++) if(m&gt;=sum[i]&amp;&amp;fir[base^i][m-sum[i]]!=0) ans+=num[i]*dp[m][i]*fir[base^i][m-sum[i]]; printf(&quot;%.10lf \\n&quot;,ans);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://partychicken.github.io/categories/ACM/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://partychicken.github.io/tags/dp/"},{"name":"期望","slug":"期望","permalink":"http://partychicken.github.io/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"基础数论总结","slug":"数论","date":"2022-04-20T03:08:41.000Z","updated":"2022-04-22T13:11:50.828Z","comments":true,"path":"2022/04/20/数论/","link":"","permalink":"http://partychicken.github.io/2022/04/20/%E6%95%B0%E8%AE%BA/","excerpt":"","text":"GCD&amp;LCM辗转相除求gcd$gcd(x,y)=gcd(y,x\\%y)$ ，易证。 12345int gcd(int x,int y)&#123; if(!y) return x; return gcd(y,x%y);&#125; 求lcm lcm(x,y) \\times gcd(x,y)=x \\times y lcm(x,y)=\\dfrac{x\\times y}{gcd(x,y)}证明： 设 $x=p\\times a$ , $y=p \\times b$ 且$gcd(a,b)=1$ 则有 $gcd(x,y)=p,lcm(x,y)=lcm(a,b)\\times p$ $a,b$ 互质 ，故 $lcm(a,b)=a\\times b ,lcm(x,y)=a\\times b\\times p$ 证毕 扩展欧几里德 ExGCD用于求方程 $ax+by=gcd(a,b)$ 的一组解 1234567891011121314int exgcd(int x,int y,int &amp;a,int &amp;b)&#123; if(!y) &#123; a=1; b=0; return x; &#125; int res=exgcd(y,x%y,a,b); int tmp=a; a=b; b=tmp-(x/y)*b; return res;&#125; 注意：代码里的 $x,y,a,b$ 与我所述的是反的 证明： 在 $ax+by=gcd(a,b)$ 中， 当 $b=0$ 时， \\begin{cases} x=1 \\\\ y=0 \\end{cases}显然为方程的一组合法解。 已知 $bx+(a\\%b)y=gcd(b,a\\%b)$ 的解，考虑向 $ax’+by’=gcd(a,b)$ 的解转移 由于 a\\%b=a-\\lfloor\\dfrac{a}{b}\\rfloor\\times b所以可得方程 bx+(a-\\lfloor\\dfrac{a}{b}\\rfloor\\times b)y=ax'+by' bx+ay-\\lfloor\\dfrac{a}{b}\\rfloor\\times by=ax'+by' ay+b(x-\\lfloor\\dfrac{a}{b}\\rfloor\\times y)=ax'+by'显然一组可行解为 \\begin{cases} x'=y\\\\ y'=x-\\lfloor \\dfrac{a}{b} \\rfloor \\times y \\end{cases}证毕 ExGCD求$ax+by=1$用ExGCD解出$ax’+by’=gcd(a,b)$的一组解后 由 \\dfrac {ax'}{gcd(a,b)}+\\dfrac{by'}{gcd(a,b)}=1可得 \\begin{cases} x=\\dfrac{x'}{gcd(a,b)}\\\\ y=\\dfrac{y'}{gcd(a,b)} \\end{cases}求得$ax+by=1$的一组解后，可由一组解扩展出所有解 显然 a(x+k\\times b)+b(y-k\\times a)=1则 \\begin{cases} x=\\dfrac{x'}{gcd(a,b)}+k\\times b\\\\ y=\\dfrac{y'}{gcd(a,b)}-k\\times a \\end{cases}为$ax+by=1$的解的通项 费马小定理如果$p$是质数，且$a$与$p$互质，则有： a^{p-1}\\equiv 1(mod\\;p)欧拉定理 a^{\\varphi(p)}\\equiv 1(mod\\;p)乘法逆元定义如果 $ab\\equiv 1(mod\\;p)$ ,则 $a,b$ 互为 $mod\\;p$ 意义下的乘法逆元 说明：众所周知，除法是不可膜的。而乘法逆元是为了使除法可膜而诞生的。即$ \\dfrac a b\\equiv a\\times inv(b)(mod\\;p)$，其中$a$为任意整数。化简可得，$b\\times inv(b)\\equiv1(mod\\;p)$ 求法费马小定理可用于解决膜数$p$为质数的情况 a^{p-1}\\equiv 1(mod\\;p)a\\times a^{p-2}\\equiv 1(mod\\;p)则$a^{p-2}$即为$a\\;mod\\;p$意义下的逆元，快速幂可求 欧拉定理可用于解决膜数$p$不为质数的情况 a^{\\varphi(p)}\\equiv 1(mod\\;p)a\\times a^{\\varphi(p)-1}\\equiv 1(mod\\;p)则$a^{\\varphi(p)-1}$即为$a\\;mod\\;p$意义下的逆元，快速幂可求 ExGCD由 a\\times inv(a)\\equiv 1(mod\\;p)可得 a\\times inv(a)+p\\times y=1Exgcd可求得解 顺便记录一下自己的智障问题：这样不是会求出很多解吗？答：$inv(a)$的所有解都是$inv(a)+k\\times p$,$mod\\;p$之后都是一样的 线性递推inv(i)=-(p/i)*inv(p\\%i)证明： 设$A=\\lfloor\\dfrac p i\\rfloor,B=p\\%i$,则$A\\times i+B=p$。 则有 A\\times i+B\\equiv 0(mod\\;p)i\\equiv-\\dfrac{B}{A}(mod\\;p)i^{-1}\\equiv-A\\times B^{-1}即 inv(i)=-(p/i)\\times inv(p\\%i)阶乘逆元可以$O(n)$求出$1!\\cdots n!$的逆元，组合数常用 a!\\times inv(a!)\\equiv1(mod\\;p)(a-1)!\\times (a\\times inv(a!))\\equiv1(mod\\;p)则 inv((a-1)!)=a\\times inv(a!)可以先求出$inv(a!)$,然后推出所有阶乘的逆元 中国剩余定理 CRT设$m_1,m_2,\\ldots,m_k$两两互素，则同余方程组 \\begin{cases}x \\equiv a_1(mod\\;m_1) \\\\x \\equiv a_2(mod\\;m_2) \\\\\\qquad\\dots \\\\x \\equiv a_k(mod\\;m_k)\\end{cases}有整数解; 并且在$mod\\;M=\\prod_{i=1}^{k}m_i$意义下有唯一解，为 x\\equiv \\sum_{i=1}^ka_iM_iinv(M_i)\\%M其中$M_i=\\dfrac{M}{m_i}$,$inv(M_i)$为$M_i\\;mod\\;m_i$意义下的逆元 扩展中国剩余定理 exCRT解同余方程 \\begin{cases}x \\equiv a_1(mod\\;m_1) \\\\x \\equiv a_2(mod\\;m_2) \\\\\\qquad\\dots \\\\x \\equiv a_k(mod\\;m_k)\\end{cases}假设我们已经解出了前 $k-1$ 组解 $x_{k-1}$，那么 $x_k$ 一定为 $x_{k-1}+t\\times LCM(m_1,m_2,\\cdots m_{k-1})$。 则有 x_{k-1}+t\\times LCM(m_1,m_2,\\cdots m_{k-1})\\equiv a_k(mod\\;m_k)用 exgcd 解同余方程即可。 扩展欧拉定理 a^b\\equiv a^{b\\%\\varphi(n)+\\varphi(n)}(mod\\;n)","categories":[{"name":"ACM","slug":"ACM","permalink":"http://partychicken.github.io/categories/ACM/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://partychicken.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"test","slug":"test","date":"2022-04-18T08:29:06.000Z","updated":"2022-04-22T11:30:24.308Z","comments":true,"path":"2022/04/18/test/","link":"","permalink":"http://partychicken.github.io/2022/04/18/test/","excerpt":"","text":"Successfully build the blog私は20歳で、学生です","categories":[],"tags":[]}],"categories":[{"name":"ICS","slug":"ICS","permalink":"http://partychicken.github.io/categories/ICS/"},{"name":"ACM","slug":"ACM","permalink":"http://partychicken.github.io/categories/ACM/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://partychicken.github.io/tags/dp/"},{"name":"期望","slug":"期望","permalink":"http://partychicken.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"数论","slug":"数论","permalink":"http://partychicken.github.io/tags/%E6%95%B0%E8%AE%BA/"}]}